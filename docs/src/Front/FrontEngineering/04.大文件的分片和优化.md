<!-- ---
title: 04.大文件的分片和优化
date: 2024-10-26
cover: 
categories:
 - 前端工程化
tags:
 - 前端造轮子
description: 
--- -->


## 如何减少页面阻塞

分片上传的一个首要目标是要尽量避免相同的分片重复上传，服务器必须要能够识别来自各个客户端的各个上传请求中，是否存在于过去分片相同的上传请求，所以服务端需要识别哪些分片是相同的。

我们定义文件内容一样的文件称为相同的文件，但是如果对比文件内容的二进制是一个非常耗时的操作，研究了之后发现可以选择基于文件内容的hash值来判断文件是否相同。

所以整个发送文件的流程就可以大概总结为：
1. 客户端计算分片的hash值，并将该hash值发送给服务端
2. 服务端通知客户端有无对应分片
3. 如果没有该文件分片，将该分片发送给服务端，服务端存储

对整个文件也需要计算整个文件的hash值，判断该文件是否上传过了，如果上传过，则不再上传，直接返回。

根绝上图的流程，可以知道，客户端有两件很重要的事情：
1. 计算分片的hash值
2. 计算整个文件的hash值

计算hash值是一个CPU密集型的任务，所以需要一个处理测罗防止其阻塞主线程。

因此可以对整个大文件上传做一个大胆的假设：绝大部分的文件上传都是新的文件上传

在这个假设的基础上，在处理文件的时候，就不需要等待整个文件的hash值计算结果，直接上传分片，同时把分片操作使用多4线程+异步的方式进行上传处理。

### upload-core中的通用函数

**EventEmitter**
统一前后端涉及到的基于各种事件的处理，使用发布订阅模式提供统一的EventEmitter类。比如
1. 前端可能出现的事件：上传进度改变事件，上传暂停/上传恢复事件
2. 后端可能出现的事件：分片写入完成事件，分片合并完成事件

```typescript
export class EventEmitter<T extends string> {
  private events: Map<T, Set<Function>>;
  constructor() {
    this.events = new Map();
  }

  on(event: T, listener: Function) {
    if(!this.events.has(event)){
      this.events.set(event, new Set());
    }
    this.events.get(event).add(listener);
  }

  off(event: T, listener: Function) {
    if(!this.events.has(event)) {
      return;
    }
    this.events.get(event).delete(listener);
  }

  once(event: T, listener: Function) {
    const onceListener = (...args: any[]) => {
      listener(...args);
      this.off(event, onceListener);
    }
    this.on(event, onceListener);
  }

  emit(event: T, ...args: any[]) {
    if(!this.events.has(event)) {
      return;
    }
    this.events.get(event).forEach(listener => listener(...args));
  }
}
```

**TaskQueue**
为支撑前后端的多任务并发执行，提供TaskQueue类，并发任务比如：
1. 前端可能得并发执行：并发请求
2. 后端可能得并发执行：并发的分片Hash校验

```typescript
export class Task {
  fn: Function; // 任务关联的执行函数
  payload?: any; // 任务关联的其他信息
  constructor(fn: Function, payload?: any) {
    this.fn = fn;
    this.payload = payload;
  }

  run() {
    return this.fn(this.payload);
  }
}
```

### 前端要处理的问题

1. 如何分片

2. 控制请求
