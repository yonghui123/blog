---
title: 07.worker
date: 2024-11-04
cover: 
categories:
 - 前端
tags:
 - javascript
description: 
---

## 什么是webworker
在浏览器的事件循环中，我们知道不同的线程会处理不同的任务，默认的线程比如http线程、io线程等等。
如果我们想在浏览器中进行复杂的计算，如果都在主线程操作，那么主线程就会阻塞，导致页面的响应不及时，造成卡顿。
那么有没有什么办法可以让主线程和计算线程分离呢？答案是webworker。

webworker允许我们开启一个单独的线程，去处理一些复杂的计算任务，当计算完成之后，通过回调的形式通知主线程，主线程只要处理拿到计算结果之后的逻辑就可以了。

## webworker 使用

1. 创建一个worker实例
```javascript
const worker = new Worker('./worker.js') 
// 如果需要指定worker的js可以使用ESM，可以添加type参数
const worker = new Worker('./worker.js', {type: 'module'})

```

2. 告诉worker开始工作
```javascript
worker.postMessage('开始工作')
```

3. 监听worker的消息
```javascript
worker.onmessage = (e) => {
  // 内部worker执行完了，或者执行到某个节点了
}
```

4. 关闭worker
```javascript
worker.terminate()
```

5. worker内部如何与主线程通信
```javascript
self.onmessage = (e) => {
  // 收到了外部worker的消息
  // 复杂逻辑
  self.postMessage('计算完成')
}
```
