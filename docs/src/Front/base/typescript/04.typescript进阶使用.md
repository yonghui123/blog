
## 理解类和接口

js本身不适合做一些大型的复杂项目，因为这些大型项目在开发过程中需要不断的拆分和细化，拆分之后会产生大量的方法和对象，
在调用这些方法和对象的时候，尽管开发者可以通过注释，文档或者记忆力来约束，但是这些约束方式并不会强行约束开发者必须怎么做（强约束力）。
从而导致项目复杂度越来越高，维护难度也越来越大。  

ts完整的类型系统，会对所有代码进行类型检查，并且这种检查具有强约束力。  
这种强约束力的好处是在对数据进行抽象和细分的时候，底层封装的接口不会被上层应用所破坏（只可以调用底层提供的接口修改）。  
这种改动，为面向对象开发带来了便利，让开发大型应用成为了可能。  

面向对象开发在大型应用开发中应用了多年，积累了丰富的经验，已经形成了多种开发模式，能处理复杂问题。  

### 面向对象的概念

面向对象：Oriented Object 

面向对象是一种开发思想，不特指某种编程语言。他提出将现实世界的物体使用对象来表示，对象是一种由属性和方法构成的抽象概念。  
面向对象以对象作为切入点，通过构建对象以及对象之间的联系，来处理问题。  

**面向对象的开发思维**  
> 专业的人处理专业的事。
举个例子：在一个公司中，有不同的岗位，销售负责推销产品，开发负责开发产品等等。  

在面向对象的思想中，将一个复杂的问题拆分为一个一个的小问题，小问题交给专业的人来处理。  
在开发过程中，专业可以表述为一个类，他是某一种职位或者岗位的统称，是同一种特征的一个描述，也可以是同一种特征的模版。
比如：前端开发工程师可以描述为一个类，这类人会开发网页等。  
只有专业显然并不能处理解决问题，所以需要有人学会这些技能（具备这些特征），只有落实到某一个专业的人，才能解决问题。
这个专业的人在开发过程中表述为一个对象，他具备有某种专业的技能。  

所以在面向对象的开发思维中，对于某个问题，我们需要将其划分成不同的类（明确需要解决哪些问题），将类实例化成对象（通过专业找到专业的人），
`让专业的人解决专门的问题`。  

### 理解类

**1. 类的使用**  

```typescript
// 要开发网页，需要找一个前端开发程序员
// 他的专业是前端开发
class FrontEnginer {
  name: string;
  skills: string[];
  constructor(name: string, skills: string[]) {
    this.name = name;
    this.skills = skills;
  }

  develop() {
    console.log(`${this.name} can use ${this.skills.join(" or ")} to develop web page.`);
  }
}
// 根据前端开发这个职业，找到一个前端开发程序员
const xiaoli = new FrontEnginer("小李", ["html", "css", "js"]);
xiaoli.develop();
```

**2. 类的继承**  

在开发过程中，类的继承更多类似于衍生的概念，比如：  
要开发一个网页应用程序，需要开发人员（程序员），简单应用可以一个人解决，复杂应用就需要多个人配合，并进行分工。  
前端程序员负责页面开发，后端程序员负责服务端开发，而这两者都可以成为程序员，他们有一样的能力（coding），但是有自己的专长。  

如何区分使用类的继承：  
当可以描述一个事物B是另一个事物A的一种，那么就需要使用继承。  
例如：  
前端程序员是程序员，后端程序员也是程序员
那么可以描述为：前端程序员是程序员子类，程序员是前端程序员父类

类似的描述有：
- 前端程序员继承了程序员
- 程序员派生了前端程序员

```typescript
class Programmer {
  name: string = 'Programmer'
  ability() {
    console.log("coding");
  }
}

class FrontEnginer extends Programmer {
  name: string = 'FrontEnginer'
  ability() {
    console.log("coding");
  }
  skill() {
    console.log("html,css,js");
  }
}

class BackEnginer extends Programmer {
  name: string = 'BackEnginer'
  skill() {
    console.log("nodejs,mysql");
  }
}

```

在继承的时候，子类可以覆盖父类的属性和方法。  

- 覆盖属性的时候，只能覆盖属性的值，不能覆盖属性的类型。  
- 覆盖方法，可以覆盖方法体







