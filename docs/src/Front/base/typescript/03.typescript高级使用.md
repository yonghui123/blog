## typescript 中的模块化

需要的相关配置

- target: 编译的目标代码（书写的 ts 代码）的执行标准
- module: 设置编译结果中使用的模块化标准
- moduleResolution: 设置解析模块的模式
- noImplicitUseStrict: 编译的结果中不包含`use strict`
- removeComments: 编译结果移除注释
- noEmitOnError: 编译错误时不生成编译结果
- esModuleInterop: 启用 es 模块化交互非 es 模块导出

在 ts 里面统一使用 ES6 的模块化就可以。

如果设置 target 和 module 是一样的（都是 es6），那么编译结果只是将类型约束去掉。

如果设置要编译的结果是`commonjs`，ts 会将 es6 模块化语法转换成 commonjs 模块化语法。

**解决在 commonjs 默认导入的问题**  
通常在写 nodejs 代码的时候，由于一些内置模块都是使用 commonjs 的模块化，如果使用 es6 模块化导入的话，会出现一些问题：

```typescript
import fs from "fs";
```

这样是无法导入 fs 模块的，从编译结果来看，在调用 fs 里面的方法的时候，会自动加上一个 default。所以找不到该模块中的方法。

解决方法：

1. 直接导入模块中的方法：

```typescript
import { readFileSync } from "fs";
```

2. 导入 commonjs 中所有导出的内容：

```typescript
import * as fs from "fs";
```

3. 开启 esModuleInterop 配置。

**在 ts 中模块解析策略**：

1. classic: 经典的解析策略，目前已经很少使用了。
2. node: nodejs 的解析策略，但是如果不写文件后缀名，查找的是 ts 文件，而不是 js 文件（编译前）。

## 接口和类型兼容性

### 接口

接口是 ts 中的一个扩展类型。用于约束类，对象，函数的类型。

1. 使用接口约束对象：

```typescript
interface Person {
  name: string;
  age: number;
}

let p1: Person = {
  name: "zhangsan",
  age: 18,
};
```

这种情况和使用类型别名区别不大。

2. 使用接口约束函数：

使用接口约束函数的方法，和类名别名是一样的。

- 约束对象中的函数（方法）:

```typescript
interface Person {
  name: string;
  age: number;
  describe: () => void;
}
```

- 直接约束函数；

```typescript
interface Describe {
  (): void;
}
```

扩展一个接口类型，通过继承可以获得其他接口中定义的属性和方法。

```typescript
interface Person {
  name: string;
  age: number;
}
interface Student extends Person {
  grade: number;
}
interface Worker extends Student {
  salary: number;
}
```

通过类型别名也可以实现同样的效果。这种实现方式叫做交叉类型

```typescript
type Person = {
  name: string;
  age: number;
};
type Student = Person & {
  grade: number;
};
type Worker = Student & {
  salary: number;
};
```

区别： 在接口中使用继承扩展类型的时候，不可以修改继承的属性。
使用交叉类型扩展类型的时候，如果有同名属性，并且属性类型不一样，那么会将两个类型也进行交叉。但是如果同名属性都是一个不同的基本类型，那么 ts 会推断一个永远不存在的类型， 即 never。  
比如: `string`类型和`number`类型在做交集的时候，不会有交叉，所以生成的类型是一个不存在的类型。

**typescript 中 readonly 关键词**  
主要是对对象或者数组中的属性约束为只读属性，对于变量使用 const 关键字定义即可。

1. 约束数组

```typescript
let arr: readonly number[] = [1, 2, 3];
```

这种限制方式不影响数组重新复制，影响的是数组中的每个元素，以及可以影响数组的方法。  
比如以下方法都不可以使用：

```typescript
arr1[0] = 2;
arr1.push(4);
arr1.pop();
arr1.shift();
arr1.unshift(0);
arr1.splice(1, 2);
```

2. 约束对象

```typescript
type Person = {
  readonly id: number;
};

// 或者
interface Person {
  readonly id: number;
}
```

表示该属性初始化定义之后不可修改。

3. 约束对象中的数组

```typescript
type Person = {
  readonly arr: number[];
};
```

这样的写法，只能约束数组中的 arr 属性不能重新赋值。而不能约束数组中的元素。

```typescript
type Person = {
  readonly arr: readonly number[];
};
```

这个写法，不仅会约束数组不能重新赋值，而且会约束数组中的元素也不能修改。

### 类型兼容性

两个类型兼容的时候，才可以完成不相等赋值。

**如何判断类型兼容**  
在 ts 中，主要使用鸭子辩型法(或者叫子结构辩行法)：  
目标类型需要某一些特征，比如在程序中我们认为鸭子的特征是会游泳，那么赋值的类型中只需要包含这个特征，就可以赋值成功，即两个类型兼容。

主要分为：

1. 基本类型

要求完全匹配，不可能有一个既是字符串又是数字的类型。

2. 对象类型兼容

通过鸭子辩型法的方式来判断两个对象是否兼容；

```typescript
interface Duck {
  swim(): void;
}

let duckLike = {
  swim() {},
  name: "duck",
  identity: "A man who looks like a duck",
};

let d: Duck = duckLike;
```

`duckLike` 对象符合`Duck`接口的要求的特征，所以`duckLike`可以赋值给`Duck`类型。  
这样判断的好处是，如果这个对象是从接口中获取到的，那么可能服务端返回的数据前端不会全部用到，这个时候，前端只取用需要的字段即可，多余的字段会自动兼容。  
但是如果将对象作为字面量赋值的时候，那么 ts 会进行严格判断。即赋值的字面量一定完全匹配接口定义的类型。

```typescript
let d2: Duck = {
  // 这里只能有Duck接口中已经定义的属性
  swim() {},
};
```

这是因为，ts 假设，当开发者显式的使用字面量赋值的时候，开发者是需要确定赋值的类型的，防止出现拼写错误等人为的错误。  
这个设计是极其符合前端开发者的开发习惯的。  

3. 函数类型兼容

函数的类型兼容是函数定义时的类型和使用时的类型的兼容： 

```typescript
interface Condition {
  (value: number, index: number): boolean;
}
```

- 作为普通函数直接定义：类似于对象直接赋值字面量，调用时的参数和返回值类型必须和声明时完全一致。  

```typescript
const condition: Condition = (value, index) => {}
// 先定义后使用，使用时必须完全匹配
condition(1, 2);
```

- 作为方法的参数（回调函数）：类似于对象中先定义对象后赋值，函数的参数和定义时顺序相同，但是不要求数量和定义时也完全一致，需要几个参数，就获取几个参数。
  但是需要注意，获取的参数数量不可以多余定义时参数的数量。  
  函数的返回值类型，如果声明时要求有返回值，那么一定要和定义时的返回值类型一致， 如果不要求有返回值，那么返不返回都可以。
  
```typescript
interface Condition {
  (value: number, index: number): boolean;
}
// 在此时定义Condition方法接口，定义了函数的参数类型，返回值类型，参数数量
function filter(array: number[], condition: Condition): number[] {
  for(let i = 0; i < array.length; i++) {
    if(condition(array[i], i)) {}
  }
}
```

## typescript 中的类

typescript中对类的语法进行了扩展。  

### 属性
在ts中的类中，需要使用属性列表来定义类的属性。  
因为ts认为，类和对象一样，在初始化的时候就需要知道其中有多少个属性，不可以在运行时再添加属性。  
所以，在ts中，类中定义的属性，必须先声明，然后再使用。  
```typescript
class Person {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}
```

属性列表中的属性，初始值默认是undefined（没有在定义时或者在constructor中赋值）。如果忘记了赋值在使用的时候可能会造成一些问题。  
可以开启一个配置项：strictPropertyInitialization，来禁止未初始化的属性。  

初始化属性有两种方式：
```typescript
class Person {
  name: string;
  age: number;
  // 1. 在定义属性列表时直接赋值
  gender: 'male' | 'female' = 'male';
  // 2. 在构造函数的参数中直接给出默认值
  constructor(name: string, age: number, gender: 'male' | 'female' = 'male') {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
}
```

一些属性在初始化之后不希望再次修改：
```typescript
class Person {
  readonly id: string;
}
```









