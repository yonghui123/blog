
## typescript 中的模块化

需要的相关配置

- target: 编译的目标代码（书写的ts代码）的执行标准
- module: 设置编译结果中使用的模块化标准  
- moduleResolution: 设置解析模块的模式  
- noImplicitUseStrict: 编译的结果中不包含`use strict`  
- removeComments: 编译结果移除注释
- noEmitOnError: 编译错误时不生成编译结果
- esModuleInterop: 启用es模块化交互非es模块导出  

在ts里面统一使用ES6的模块化就可以。  

如果设置target和module是一样的（都是es6），那么编译结果只是将类型约束去掉。  

如果设置要编译的结果是`commonjs`，ts会将es6模块化语法转换成commonjs模块化语法。  

**解决在commonjs默认导入的问题**  
通常在写nodejs代码的时候，由于一些内置模块都是使用commonjs的模块化，如果使用es6模块化导入的话，会出现一些问题：
```typescript
import fs from 'fs';
```
这样是无法导入fs模块的，从编译结果来看，在调用fs里面的方法的时候，会自动加上一个default。所以找不到该模块中的方法。

解决方法：
1. 直接导入模块中的方法：
```typescript
import { readFileSync } from 'fs';
```
2. 导入commonjs中所有导出的内容：
```typescript
import * as fs from 'fs';
```
3. 开启esModuleInterop配置。  

**在ts中模块解析策略**：  
1. classic: 经典的解析策略，目前已经很少使用了。  
2. node: nodejs的解析策略，但是如果不写文件后缀名，查找的是ts文件，而不是js文件（编译前）。

## 接口





