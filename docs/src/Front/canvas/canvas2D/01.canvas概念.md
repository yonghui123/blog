---
title: 01.canvas概念
date: 2025-04-24
cover: img/front/canvas.jpg
categories:
  - 前端
tags:
  - canvas
  - canvas2D
description: 初步介绍canvas，及canvas的相关概念
---


## canvas概述

canvas 是html5提供的一个新的标签，用于在浏览器中进行更加丰富的绘制。相当于浏览器提供的一个画布。  

canvas本身只是一个标签，真正具备绘制能力的是js提供的一系列相关的API。  

canvas绘制的是一个位图，所以在缩放的时候，会有失真的现象，在有缩放需求的时候尽量保持在一定比例之内。  

canvas可以对画布中每一个像素点进行操作， 结合图形学，可以高度自定义每一个像素的内容和动画效果

canvas绘制的内容不属于DOM元素，所以可以脱离DOM进行绘制。  
同样的，由于绘制元素不属于DOM，所以无法在浏览器中查看，也无法给某一部分元素添加事件（但是可以通过对canvas元素的监听，实现对其内部元素的监听）。  

## canvas绘制的组成

在canvas绘制可以类比成现实生活中的画画。  
其中canvas标签就可以视为画布（提供绘制的区域），通过js创建的context可以视为画笔（提供绘制某个像素点的颜色等能力）。  

这部分绘制的是2D绘图，所以context都是指的是`CanvasRenderingContext2D`。  

创建画布和画笔:
```js
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById("canvas")
/** @type {CanvasRenderingContext2D} */
const context = canvas.getContext("2d");
```
**canvas的大小**：  
canvas标签是一个行内元素，但是canvas可以使用width和height属性设置宽高（默认为300 * 150）。  

canvas也可以使用css来设置宽高，但是其效果跟属性设置的略有不同：  
- 使用width属性和height属性设置的区域，可以称为**画布区域**，我们所有绘制的图形都需要在该区域内，才会绘制，超出该区域则不会绘制。  
- 使用style样式设置的区域，可以成为**实际显示区域**，比如一米多高的人，拍出来全身照也能显示在13寸的手机上，绘制的内容会根据该区域的大小进行缩放。相框中是最终显示到浏览器中的内容。  

## canvas绘制基础图形

### 绘制矩形

在canvas中绘制的矩形可以分为填充矩形（实心矩形）和描边矩形（空心矩形）

**1. 直接绘制描边矩形**
`context.strokeRect(x, y, width, height)`, 从`(x, y)`开始绘制一个宽为`width`,高为`height`的空心矩形。  
```js
// 从(10, 10)的位置开始，绘制一个宽为30，高为40的空心矩形
context.strokeRect(10, 10, 30, 40);
```
**2. 直接绘制填充矩形**  
`context.fillRect(x, y, width, height)`, 从`(x, y)`开始绘制一个宽为`width`,高为`height`的实心矩形。 
```js
// 从(10, 10)的位置开始，绘制一个宽为30，高为40的空心矩形
context.fillRect(10, 10, 30, 40);
```

**3. 先规划，再绘制**
`context.rect(x, y, width, height)`, 规划了一个从`(x, y)`开始，宽为`width`,高为`height`的矩形，但是并没有进行实际绘制。 
```js
context.rect(10, 10, 30, 40);
// 规划了一个。。。的矩形区域，但是没有实际效果
// 要进行实际绘制，还要再配合两个方法使用
context.fill(); // 将上述矩形填充
context.stroke(); // 将上述矩形描边
```

如果想要设置填充和描边颜色，必须要在实际绘制之前（所有针对当前次绘制的样式都是）。

**4. 添加颜色**

```js
context.rect(10, 10, 30, 40); // 没有发生实际绘制
context.strokeStyle = "#f00"; // 将描边绘制成红色
context.stroke(); // 发生了实际绘制
context.fillStyle = "#0f0"; // 将填充设置为绿色
// 只要在发生绘制之前设置好样式即可
context.fill(); // 发生了实际绘制
```

### beginPath 分组绘制

在使用canvas绘制图形的时候，通常会先绘制路径，在填充颜色，最终将图形绘制出来，比如下面代码：
```js
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
canvas.width = 800;
canvas.height = 600;
document.body.appendChild(canvas);

// 线绘制一个红色矩形
ctx.rect(10, 10, 100, 100);
ctx.fillStyle = 'red';
ctx.fill();
// 再绘制一个蓝色矩形
ctx.rect(130, 10, 100, 100);
ctx.fillStyle = 'blue';
ctx.fill();
```

但是上述代码不会按照注释一样分别绘制红色和蓝色矩形，而是会在最后一次执行绘制命令`ctx.fill()`的时候将之前设置的所有路径都按照最后设置的样式进行绘制，也就是会得到两个蓝色矩形。

如果需要对每一个路径分别进行绘制，就需要对路径进行分组。

```js
ctx.beginPath();
ctx.rect(10, 10, 100, 100);
ctx.fillStyle = 'red';
ctx.fill();

ctx.beginPath();
ctx.rect(130, 10, 100, 100);
ctx.fillStyle = 'blue';
ctx.fill();
```
当遇到调用`beginPath`方法时，会将后续的绘制视为一组。直到遇到下一个`beginPath`。  

分组绘制的路径不一定只有一个路径，如果遇到多个路径有一样的样式，可以将多个路径先进行绘制。  

如果一个分组中没有对路径调用绘制命令，那么最终该路径也不会绘制。  

beginPath只对绘制命令有影响，对于画笔的状态--颜色，线框宽度等是没有影响的：
```js
ctx.beginPath();
ctx.rect(10, 10, 100, 100);
ctx.fillStyle = 'red';
ctx.lineWidth = 5;
ctx.strokeStyle = 'black';
ctx.fill();

ctx.beginPath();
ctx.rect(130, 10, 100, 100);
ctx.stroke();
```
在上述代码中，虽然第二次分组中没有设置线框颜色和宽度，但是依然会使用第一次设置的绘制出一个宽度为5，黑色的边框。

### roundRect 圆角矩形

在设置矩形的圆角的时候，可以有多种设置方式（类似于border-radius）：  
1. 可以统一设置四个角：
```js
// 圆角矩形
ctx.roundRect(10, 120, 100, 100, 10);
ctx.strokeStyle = '#ff1100';
ctx.lineWidth = 5;
ctx.stroke();
```

2. 第五个参数对应设置圆角，也可以设置为一个数组，数组中有1到4个值。
  - 只有一个值： 同时设置四个角为同一个值
  - 有两个值： 分别对应↖，↘ 和 ↗，↙，对角值
  - 有三个值： 分别对应↖，和 ↗，↙ 和 ↘
  - 有四个值： 分别对应↖ 和 ↘ 和 ↗ 和 ↙

### 绘制线段 - 直线和折线  

两个点绘制成一条直线，在生活中画一条直线要先将画笔移动到起点，再将画笔按在画布上移动到终点，这两个动作在canvas中分别对应`moveTo`(将画笔悬空移动到起点)和`lineTo`（将画笔按在画布上移动到终点）

```js
ctx.beginPath();
// 将笔触移动到（130， 130）
ctx.moveTo(130, 130);
// 绘制一个直线：起点为（130， 130） 终点为（230， 130）
ctx.lineTo(230, 130);
// 由于没有再次移动笔触，所以新的直线的起点就是上一条直线的终点
// 绘制一个直线：起点为（230， 130） 终点为（230， 230）
ctx.lineTo(230, 230);
ctx.strokeStyle = '#00ff11';
ctx.lineWidth = 5;
ctx.stroke();
```
可以看到多次连续调用`lineTo`（连续调用中没重新将画笔悬空移动到另一个为止）就可以形成一个折线。  

**直线样式设置相关API**  

1. lineCap: 设置线段两端的端点的样式。可以设置的值有：  
  - butt: 默认值，没有效果，线段两端是平的
  - round: 线段两端是圆的，是在线段两点之外添加了一个半圆
  - square: 也是平的，但是会在线段两点之外添加一个矩形

2. lineJoin: 设置折线连接处的样式（不包含折线起止点），可以设置的值有： 
  - miter: 默认值,连接处是尖的
  - round: 连接处是圆的
  - bevel: 连接处是平的

3. miterLimit: 当lineJoin的值为miter时，会将两条线段的外沿进行延长，最终交于一个点。当两条线段特别粗，夹角又比较小的时候，延长线的交点可能会特别远。可以通过这个值进行限制。 

4. 设置虚线：可以通过`setLineDash`方法进行设置，该方法可以传入一个数组，数组中的值分别表示**留白**和**线段**的长度：
```js
ctx.beginPath();
ctx.moveTo(10, 250);
ctx.lineTo(110, 250);
ctx.setLineDash([5, 15]);
ctx.strokeStyle = '#0000ff';
ctx.lineWidth = 5;
ctx.stroke();
```
数组中下标为偶数的表示线段的长度（0， 2， 4 。。。），下标为奇数的表示留白的长度（1， 3， 5 。。。）。

数组中的数据会作为基础数据不断重复，所以根据数组中元素的数量会有不同的效果: 
  - 数组中只有一个元素： 表示线段和留白都一样
  - 数组中元素数量为奇数： 比如[10, 20, 30]，排列顺序就会变成线段10，留白20，线段30，留白10，线段20，留白30 。。。 不断重复
  - 数组中元素数量为偶数： 比如[10, 20]，排列顺序为线段10，留白20...不断重复

5. lineDashOffset: 设置虚线起始位置的偏移量,正数往左偏移，负数往右偏移







