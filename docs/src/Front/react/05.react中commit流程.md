---
title: 05.react中commit流程
date: 2025-02-27
cover: img/front/react.png
catrgories:
 - 前端
tags:
 - react
description: 梳理了解commit的执行流程
---

在React中整个渲染过程分为：
- render阶段
  - Scheduler 调度任务，将任务放到message channel中
  - Reconciler 协调任务，生成wipFiberTree，diff算法判断并标记当前节点是否需要更新
- commit阶段，将标记的更新应用到渲染层

## commit阶段

commit阶段分为三个子阶段：  
- before mutation阶段，组件实际DOM更新前执行某些操作
- mutation阶段，开始实际修改DOM
- layout阶段，组件实际DOM更新后执行某些操作，比如useEffect

每个阶段都会通过DFS遍历FiberTree，执行对应的操作。

### before mutation阶段

从调用`commitBeforeMutationEffects`开始，表示进入了before mutation阶段。该函数主要将开始更新的节点保存到一个全局变量中，然后调用`commitBeforeMutationEffects_begin`开始通过DFS的方式遍历FiberTree。如果找到一个节点没有关联的当前显示的节点，或者没有标记的需要更新的flags，则进入`commitBeforeMutationEffects_complete`阶段。该阶段会判断是否有兄弟节点，如果没有则返回上一层。在其中会调用`commitBeforeMutationEffectsOnFiber`方法，这个方法对应在before mutation阶段执行的操作。可以看到在该阶段，主要是对DOM进行一些准备工作。

查看具体的实现：
```javascript
function commitBeforeMutationEffectsOnFiber(
  finishedWork: Fiber,
  isViewTransitionEligible: boolean,
) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;

  switch (finishedWork.tag) {
    // 函数组件，将该组件的函数实现更新到最新的实现
    case FunctionComponent: {
      if (enableUseEffectEventHook) {
        if ((flags & Update) !== NoFlags) {
          const updateQueue: FunctionComponentUpdateQueue | null =
            (finishedWork.updateQueue: any);
          const eventPayloads =
            updateQueue !== null ? updateQueue.events : null;
          if (eventPayloads !== null) {
            for (let ii = 0; ii < eventPayloads.length; ii++) {
              const {ref, nextImpl} = eventPayloads[ii];
              ref.impl = nextImpl;
            }
          }
        }
      }
      break;
    }
    // 类组件，捕获组件快照，确保在更新之前获取到最新的状态
    case ClassComponent: {
      if ((flags & Snapshot) !== NoFlags) {
        if (current !== null) {
          commitClassSnapshot(finishedWork, current);
        }
      }
      break;
    }
    // 当前节点是根节点，那么将根节点清空，为新内容腾出空间
    case HostRoot: {
      if ((flags & Snapshot) !== NoFlags) {
        if (supportsMutation) {
          const root = finishedWork.stateNode;
          clearContainer(root.containerInfo);
        }
      }
      break;
    }
  }
}
```

### mutation阶段

在mutaion阶段，从`commitMutationEffects`函数作为入口点，在该函数中调用`commitMutationEffectsOnFiber`实现mutation阶段具体的操作。  

具体实现：
```javascript
function commitMutationEffectsOnFiber(
  finishedWork: Fiber,
  root: FiberRoot,
  lanes: Lanes,
) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectErrors = pushComponentEffectErrors();
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;

  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);

      if (flags & Update) {
        commitHookEffectListUnmount(
          HookInsertion | HookHasEffect,
          finishedWork,
          finishedWork.return,
        );
        // TODO: Use a commitHookInsertionUnmountEffects wrapper to record timings.
        commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork);
        commitHookLayoutUnmountEffects(
          finishedWork,
          finishedWork.return,
          HookLayout | HookHasEffect,
        );
      }
      break;
    }
    case ClassComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);

      if (flags & Ref) {
        if (!offscreenSubtreeWasHidden && current !== null) {
          safelyDetachRef(current, current.return);
        }
      }

      if (flags & Callback && offscreenSubtreeIsHidden) {
        const updateQueue: UpdateQueue<mixed> | null =
          (finishedWork.updateQueue: any);
        if (updateQueue !== null) {
          deferHiddenCallbacks(updateQueue);
        }
      }
      break;
    }

    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);

      if (flags & Ref) {
        if (!offscreenSubtreeWasHidden && current !== null) {
          safelyDetachRef(current, current.return);
        }
      }
      if (supportsMutation) {
        // TODO: ContentReset gets cleared by the children during the commit
        // phase. This is a refactor hazard because it means we must read
        // flags the flags after `commitReconciliationEffects` has already run;
        // the order matters. We should refactor so that ContentReset does not
        // rely on mutating the flag during commit. Like by setting a flag
        // during the render phase instead.
        if (finishedWork.flags & ContentReset) {
          commitHostResetTextContent(finishedWork);
        }

        if (flags & Update) {
          const instance: Instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            const newProps = finishedWork.memoizedProps;
            const oldProps =
              current !== null ? current.memoizedProps : newProps;
            commitHostUpdate(finishedWork, newProps, oldProps);
          }
        }

        if (flags & FormReset) {
          needsFormReset = true;
          if (__DEV__) {
            if (finishedWork.type !== 'form') {
              // Paranoid coding. In case we accidentally start using the
              // FormReset bit for something else.
              console.error(
                'Unexpected host component type. Expected a form. This is a ' +
                  'bug in React.',
              );
            }
          }
        }
      }
      break;
    }



   



  }


}
```

