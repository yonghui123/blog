---
title: 02.react核心知识点
date: 2025-02-12
cover: img/front/react.png
catrgories:
 - 前端
tags:
 - react
description: 从框架到核心，从外往内的梳理react相关的核心知识点
---

## 1. 前端框架的理解

在现代开发中，react，vue等并不能称为一个完整的框架，而是一个用于渲染ui的库，单纯的这两个库只提供了组件化开发和基于状态的声明式渲染。  

在实际开发中，还需要对路由的控制，所以react有了react-router，vue有了vue-router。  

随着项目复杂度提升，组件增多，组件间的状态管理越来越复杂，需要一些状态管理库，react有了redux，vue有了vuex，pinia。

为了满足seo的要求，可能还需要加入ssr渲染。

后续提到的这些功能，在vue和react中并不支持。  

于是就又推出了很多企业级的解决方案，将上述这些库以及一些更多库封装到一起，组成一个框架，比如：

1. UmiJs 基于react，内置路由，构建，部署等功能。  
2. NextJs 基于react，支持ssr，ssg的服务端框架。  


在很多时候，会听到react框架，vue框架的说法，这种说法，往往指的是这两大库包含了他周边的产品。可以算是一种约定俗成的说法。

## 2. React架构

React16之前使用的是Stack架构，采用递归的方式进行虚拟dom比较。React16之后，采用的Fiber架构，可以实现时间切片，防止JS的计算阻塞渲染进程出现卡顿的现象。

在React15之前（包括React15）会存在js代码执行时间过长的问题，因为React会去重新计算整个虚拟DOM树，虽然是JS层面的计算，比实际操作DOM效率高，但是在更新过程中，他会通过递归去计算整个虚拟DOM树，这个计算过程是没办法打断的。
在这个期间，由于JavaScript是运行在渲染主线程上的，在更新期间会渲染主线程会被持续的占用，直到整个更新过程结束。如果计算量过大（超过16ms），就会导致页面在一段时间内不会响应，也就是页面卡顿。  
在React15之前，整个架构分为两个角色：
- 协调器（Reconciler）：对比计算虚拟DOM的变化
- 渲染器（Renderer）：将变化的虚拟DOM渲染到宿主环境（真实的DOM）

在React16之后，采用了Fiber架构。在Fiber架构中，虚拟DOM本质上还是表述为一个对象，但是组件中多个元素的虚拟DOM对象会以链表的形式串联起来。链表结构最大的好处是，在进行更新操作进行对比计算的时候，是可以打断的。
如果当前帧的时间不够再继续执行js，需要渲染下一帧的时候，打断js的执行，优先渲染下一帧，到下一帧的时候，再继续执行js。这样，在更新过程中，渲染主线程不会被持续的占用，页面不会出现卡顿现象。  
在React16之后，新增了一个角色
- 调度器（scheduler）: 调度任务的优先级，高优先级的任务优先执行
- 协调器（Reconciler）：除了对比虚拟DOM树的变化，还利用链表的数据结构，将任务进行分割，整个更新流程中不再使用递归，每次循环的时候根据一定条件（shouldyield）判断是否还需要继续更新。
- 渲染器（Renderer）：将变化的虚拟DOM渲染到宿主环境（真实的DOM）

## 3. React的渲染流程

在React Fiber的架构下，整个显然流程可以分为两个阶段：render阶段和commit阶段。   
其中：

render 阶段，主要目的生成新的虚拟DOM树，和旧的虚拟DOM树进行比较，从而确定哪些节点需要更新。这一阶段在Fiber中主要有两个执行者： 
  - Scheduler（调度器）: 负责根据任务的优先级安排更新任务，确保高优先级的任务优先执行
  - Reconciler（协调器）: 执行具体的协调逻辑，包括生成新的节点，比较新旧节点找出需要更新的节点等等，这个阶段可以暂停和恢复工作，以便让出渲染主线程给更重要的任务

commit 阶段，将上一阶段得到的需要更新的DOM，在这一阶段应用到宿主环境中。这一阶段主要有一个执行者：
  - Renderer（渲染器）: 将计算好的更新应用于实际的宿主环境中。

### 调度器


### 协调器


### 渲染器


