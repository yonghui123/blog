---
title: 02.react各部分渲染器
date: 2025-02-17
cover: img/front/react.png
catrgories:
 - 前端
tags:
 - react
description: 细致了解React渲染流程中各个部分的职责
---

## Scheduler 

### 1. Message Channel

创建一个消息通道，并通过MessagePort 属性来互相发送消息。

**用法**

```js
let channel = new MessageChannel();
let port1 = channel.port1;
let port2 = channel.port2;
port1.onmessage = (e) => {
  console.log('port1 received a message!');
}
port2.postMessage('port2 hello');
```

### 2. Scheduler为什么选择MessageChannel？

React的Scheduler主要负责调度任务，在调度任务的时候，需要满足两个条件

1. 可以是随时中断，将主线程还给浏览器，让浏览器能够及时的渲染页面  
2. 被中断了的js，在下一次渲染的时候能够继续执行

所以需要将更新的代码封装成浏览器的宏任务，放到任务队列中，保证在浏览器每次事件循环的时候都可以执行，并且不会阻塞渲染主线程。  

在MessageChannel中，onmessage回调函数会产生一个宏任务。  

所以React团队使用MessageChannel来调度更新任务。

> 为什么不使用setTimeout产生宏任务?
> 因为setTimeout在嵌套层级超过5层的时候，延时时间如果小于4ms，则会设置成4ms. 在HTML规范中有明确定义。
> 而在一次标准帧的执行时间是16.66ms，如果因为系统原因造成每次更新都有4ms的延时，更新任务可能需要很久才可以完成。  

> 为什么不使用requestAnimationFrame?
> 这个API的设计是将任务添加到浏览器的渲染之前，也就是说，会随着每一帧的渲染执行一次。而在一次更新任务中，可能有很多Fiber Node需要执行。
> 这个API在不同的浏览器中，具体实现是一部样的，在safari和edge中，是在渲染任务之后。在chrome中是在渲染任务之前。

> 为什么不将更新任务放在微任务中？
> 因为在一次事件循环的过程中，会冲刷所有的微任务，包括在微任务中添加的微任务。

### 3. Scheduler如何调度普通任务？


