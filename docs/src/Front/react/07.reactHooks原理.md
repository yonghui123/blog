---
title: 07.reactHooks原理
date: 2025-03-31
cover: img/front/react.png
catrgories:
 - 前端
tags:
 - react
description: 了解在react中hooks是如何将保存函数组件的状态的？以及为什么不能再循环，条件等中使用hooks
---

从源码中了解，react的函数组件是每次都会重新执行函数组件的。那么函数组件中的状态是如何保存的？

## Hooks内部介绍

在react中，针对`Hooks`的执行，分为了三种策略，这三种策略分为了三个`Dispatcher`:
1. HooksDispatcherOnMount, 在初始化的时候，将一些函数组件的初始化信息挂载到Fiber上：
```js
const HooksDispatcherOnMount: Dispatcher = {
  useCallback: mountCallback,
  useContext: readContext,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState,
  ...
};
```
2. HooksDispatcherOnUpdate,函数组件进行更新的时候，会执行该对象中的函数，此时Fiber上已经挂载了函数组件的初始化信息，只需要去获取和更新Fiber中的状态即可：
```js
const HooksDispatcherOnUpdate: Dispatcher = {
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState,
  useFormState: updateActionState,
  ...
};
```

3. ContextOnlyDispatcher, 防止开发者在函数组件外部调用Hooks, 并对相应的行为进行警告：
```js
export const ContextOnlyDispatcher: Dispatcher = {
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useMemoCache: throwInvalidHookError,
  ...
};
```

在函数组件执行过程中，尽管开发者看到的都是useXXX的hooks，但是实际上在不同的阶段，调用的函数是不一样的，

- 在初始化阶段：调用的都是mounteXXX的函数
- 在更新阶段：调用的都是updateXXX的函数
- 如果没有按照一定的规则调用hooks，会调用ContextOnlyDispatcher，并给出警告

在函数组件的执行过程中，进入render阶段之后，会对当前渲染是初次渲染还是更新进行判断：
```js
ReactSharedInternals.H =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;
```
通过赋值不同的上下文对象，在调用hooks的时候，也会调用不同的方法。  

在React中，Hook对应的数据结构：
```js
export type Hook = {
  memoizedState: any,
  baseState: any,
  baseQueue: Update<any, any> | null,
  queue: any,
  next: Hook | null,
};
```
也是一种链表结构。需要注意memoizedState字段，在FiberNode上也有一个memoizedState字段，这两个字段保存的信息是不一样的。
- FiberNode.memoizedState: 保存了Hooks链表中第一个Hook的信息。
- Hook.memoizedState: 保存了当前Hook应该保存的值。并且，不同的Hook保存的值也不一样。 
  - useState: `const [state, setState] = useState(initialState);` memoizedState保存的就是state的值
  - useReducer: `const [state, dispatch] = useReducer(reducer, initialState);` memoizedState保存的就是state的值
  - useEffect: `useEffect(callback, [...deps])` memoizedState保存的是回调函数callback和依赖数组deps
  - useRef: `const ref = useRef(initialValue);` memoizedState保存的就是{current: initialValue}
  - useMemo: `const memoizedValue = useMemo(calculateFn, [...deps])` memoizedState保存的是回调函数calculateFn和依赖数组deps
  - useCallback: `const memoizedCallback = useCallback(callback, [...deps])` memoizedState保存的是回调函数callback和依赖数组deps

## 在渲染节点，Hook的执行
当进入渲染阶段的时候，会通过`renderWithHooks`方法来调用函数组件内部的Hooks,该方法执行如下：
```js
export function renderWithHooks<Props, SecondArg>(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: (p: Props, arg: SecondArg) => any,
  props: Props,
  secondArg: SecondArg,
  nextRenderLanes: Lanes,
): any {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  // 先将当前Fiber中的memoizedState清空，此处保存的是Hooks链表中第一个Hook
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes;
  // 通过Fiber的执行阶段获取不同的执行策略，更新或者初始化
  ReactSharedInternals.H =
    current === null || current.memoizedState === null
      ? HooksDispatcherOnMount
      : HooksDispatcherOnUpdate;
  // Hooks本身是一个链表，通过链表执行函数组件中的所有hooks
  let children =  Component(props, secondArg);
  // 执行完所有Hooks之后，将状态清理
  // react所有基于某种基础数据结构的工作，都像是一个工作台，当工作结束之后，将工作台也清理干净才算真正将工作完成。
  // 此方法中最重要的是ReactSharedInternals.H = ContextOnlyDispatcher;该句阻止了一些嵌套Hooks的发生。
  finishRenderingHooks(current, workInProgress, Component);

  return children;
}

```

> 为什么在React中Hooks要放在组件的顶级代码中，并且不能使用条件和循环以及Hooks本身去嵌套？

在react函数组件的首次渲染的时候，会保存一个Hook的链表结构，这时保存的链表结构是有一个固定的顺序的。在函数组件更新的时候，会根据这个链表，进行复用和更新。如果Hook被放在了循环或者条件中，那么在更新时，链表结构就会发生改变，就会导致更新失败。
