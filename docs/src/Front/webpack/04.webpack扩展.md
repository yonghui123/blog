> webpack在打包过程中做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包到指定的文件中。  
> 如果想要实现更多的功能，需要借助loader和plugin。
## webpack loader
> loader: 本质上是一个函数，将某个源码字符串转换成另一个字符串返回。  
> loader的执行时机： 在webpack将模块文件读取成字符串之后，进行语法分析之前，会调用loader。 loader需要将字符串输出位可以做语法分析的代码生成抽象语法树。

在webpack配置中，并不是每一个模块都需要通过loader进行处理，需要一个配置项的匹配规则对匹配到的模块进行处理。如果该模块满足匹配规则，会读取规则中对应的所有loaders，然后按照顺序调用loaders，下一个loader得到的字符串，是上一个loader处理完的字符串。

loader的完整配置：
```js
module.exports = {
  module: {
    rules: [
      {
        test: /index\.js/, // 正则表达是，模块的匹配规则，是对文件的路径进行匹配
        use: [
          {
            loader: './loaders/test-loader.js', // 表示loader所在的路径
            options: {
              // 传递给loader的参数，在loader中通过this获取
              // 可以通过一些第三方库获取options， 比如loader-utils
              
            }
          }, // 每个加载器都可以是一个对象
          // 如果loader不需要参数，只有一个loader地址，可以直接写字符串
          './loaders/test-loader.js'
        ], // 匹配到了之后使用哪些规则。
      }, // 规则1
      {}, // 规则2
    ], // 对应模块的匹配规则
    noParse: [], // 不需要做语法分析的模块
  }
}
```
loader示例：
```js
const loaderUtils = require('loader-utils');
// 通过三方库获取loader的options参数
module.exports = function(source) {
  const options = loaderUtils.getOptions(this);
  console.log('loader options', options)

  return source;
}
```
如果一个模块匹配到了多个规则，那么实际的运行顺序是：
> 假设有四个loader,分别是loader1, loader2, loader3, loader4，分别属于rule[0]和rule[1]

1. 匹配阶段：先匹配到`rule[0]`,获取到`loader1`，`loader2`，将这两个loader放到一个数组`loaders=[loader1, loader2]`中。  
再匹配到`rule[1]`,获取到`loader3`，`loader4`，将这两个loader添加从末尾到loaders数组中。  
于是形成了一个要加载的loaders数组：`[loader1, loader2, loader3, loader4]`
2. 执行阶段：执行形式类似于`loader1(loader2(loader3(loader4(source))))`，执行顺序就变成了： 
`loader4 -> loader3 -> loader2 -> loader1`，loader4执行的结果交给loader3，loader3执行的结果交给loader2，loader2执行的结果交给loader1，loader1执行的结果交给webpack，webpack将loader1的结果作为模块的源码。

## webpack plugin