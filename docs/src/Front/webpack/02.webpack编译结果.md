
## webpack编译结果代码解析

> 通过实现`webpack --mode=development`编译后的代码，解析webpack的编译结果

对webpack编译结果进行逐步分析： 

### 1. 引入所有的模块

将所有模块代码包装成一个对象，每个模块的路径作为key，将每个模块代码包装到一个函数中作为value，比如：
> 有两个模块  
> 1. ./src/a.js 包含模块a的代码  
> 2. ./src/index.js 入口模块  
> 构建如下对象  
通过将模块代码放在函数中，防止了全局变量污染，并且模块可以自由选择需要导出的数据。
```js
var modules = {
  "./src/a.js": function(module, exports, require) {
    console.log('a')
    module.exports = 'a'
  },
  "./src/index.js": function(module, exports, require) {
    console.log('index')
    var a = require('./a.js')
    console.log(a)
  }
}
```

### 2. 执行模块
1. 构建函数执行所有的模块，将模块对象作为参数传递给执行函数。  
2. 执行函数通常只执行一次，所以考虑使用立即执行函数，避免污染全局变量。  
3. 模块的执行不是全部都需要执行，只有被引用的模块才需要执行，所以内部需要一个require函数，执行被导入的模块。  
4. 同一个模块被多次引用，只需要执行一次就好了，所以需要对已经执行的模块进行缓存。  
```js
(function(modules) {

  var cacheModules = {}

  function __webpack_require__(moduleId) {
    if (cacheModules[moduleId]) {
      return cacheModules[moduleId]
    }
    var func = modules[moduleId]
    var module = {
      exports: {}
    }
    func(module, module.exports, __webpack_require__)
    cacheModules[moduleId] = module.exports
    return module.exports
  }

  // 该函数只需要通过require导入入口模块就可以了
  // 避免和CommonJS中的require函数冲突，这边叫__webpack_require__
  return __webpack_require__('./src/index.js')
})(
  // 函数立即执行，将模块对象直接作为参数，避免污染全局变量
  {
  "./src/a.js": function(module, exports, require) {
    console.log('a')
    module.exports = 'a'
  },
  "./src/index.js": function(module, exports, require) {
    console.log('index')
    var a = require('./a.js')
    console.log(a)
  }
})
```

### 3. 了解webpack打包中development和production的差异

1. development模式下： 模块代码不会进行压缩，并且会放在`eval()`中执行，这样执行的时候，js会在一个虚拟环境执行，  
如果有错误，错误提示不会在webpack执行函数中，而是在eval提供的虚拟环境中。  
可以指定虚拟环境的名字为模块id，方便快速调试错误
2. production模式下： 模块代码会进行压缩，编译然后执行，保证在生产环境的执行效率






