> webpack在打包过程中做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包到指定的文件中。  
> 如果想要实现更多的功能，需要借助loader和plugin。
## webpack loader
> loader: 本质上是一个函数，将某个源码字符串转换成另一个字符串返回。  
> loader的执行时机： 在webpack将模块文件读取成字符串之后，进行语法分析之前，会调用loader。 loader需要将字符串输出位可以做语法分析的代码生成抽象语法树。

在webpack配置中，并不是每一个模块都需要通过loader进行处理，需要一个配置项的匹配规则对匹配到的模块进行处理。如果该模块满足匹配规则，会读取规则中对应的所有loaders，然后按照顺序调用loaders，下一个loader得到的字符串，是上一个loader处理完的字符串。

loader的完整配置：
```js
module.exports = {
  module: {
    rules: [
      {
        test: /index\.js/, // 正则表达是，模块的匹配规则，是对文件的路径进行匹配
        use: [
          {
            loader: './loaders/test-loader.js', // 表示loader所在的路径
            options: {
              // 传递给loader的参数，在loader中通过this获取
              // 可以通过一些第三方库获取options， 比如loader-utils
              
            }
          }, // 每个加载器都可以是一个对象
          // 如果loader不需要参数，只有一个loader地址，可以直接写字符串
          './loaders/test-loader.js'
        ], // 匹配到了之后使用哪些规则。
      }, // 规则1
      {}, // 规则2
    ], // 对应模块的匹配规则
    noParse: [], // 不需要做语法分析的模块
  }
}
```
loader示例：
```js
const loaderUtils = require('loader-utils');
// 通过三方库获取loader的options参数
module.exports = function(source) {
  const options = loaderUtils.getOptions(this);
  console.log('loader options', options)

  return source;
}
```
如果一个模块匹配到了多个规则，那么实际的运行顺序是：
> 假设有四个loader,分别是loader1, loader2, loader3, loader4，分别属于rule[0]和rule[1]

1. 匹配阶段：先匹配到`rule[0]`,获取到`loader1`，`loader2`，将这两个loader放到一个数组`loaders=[loader1, loader2]`中。  
再匹配到`rule[1]`,获取到`loader3`，`loader4`，将这两个loader添加从末尾到loaders数组中。  
于是形成了一个要加载的loaders数组：`[loader1, loader2, loader3, loader4]`
2. 执行阶段：执行形式类似于`loader1(loader2(loader3(loader4(source))))`，执行顺序就变成了： 
`loader4 -> loader3 -> loader2 -> loader1`，
loader4执行的结果交给loader3，loader3执行的结果交给loader2，loader2执行的结果交给loader1，loader1执行的结果交给webpack，webpack将loader1的结果作为模块的源码。

### 使用loader处理图片
```js

const loaderUtil = require('loader-utils');

function loader(source) {
  // let base64Data = getBase64(source);
  let imgPath = getFilePath.call(this, source);
  return `module.exports = \`${imgPath}\``;
}

loader.raw = true; // 告诉webpack这里需要数据的原始格式（二进制）

module.exports = loader;

/**
 * 将图片的二进制数据转换为base64
 * @param {*} buffer 图片的二进制数据
 * @returns 
 */
function getBase64(buffer) {
  return 'data:image/jpeg;base64,' + buffer.toString('base64');
}

/**
 * 生成文件在打包后dist中的路径
 * @param {*} buffer 
 */
function getFilePath(buffer) {
  // contenthash 表示针对单独一个模块文件生成的hash
  let filename = loaderUtil.interpolateName(this, '[name]_[contenthash].[ext]', { content: buffer })
  console.log('filename: ', filename);
  this.emitFile(filename, buffer);
  return filename;
}

```

## webpack plugin

在某些情况下，需要将功能嵌入到webpack的编译流程中（比如在生成文件后时多生成一个描述，当开始编译的时候控制台输出一句话等等），这样的实现必须依赖plugin。   

在webpack的打包过程中，每一步执行完毕都会触发一系列的事件，这些事件就是用户在配置文件中定义的钩子函数。  

plugin的本质就是一个带有apply方法的对象。  

```js
class MyPlugin {
  apply(compiler) {
    compiler.hooks.done.tap('MyPlugin', (stats) => {})
  }
}
```
在webpack的配置文件中：
```js
// webpack.config.js
const MyPlugin = require('./plugins/my-plugin');
module.exports = {
  plugins: [
    new MyPlugin();
  ]
}
```
apply的参数compiler是webpack的编译对象，他是在webpack初始化阶段构建的，整个webpack打包期间只有一个compiler对象。
后续打包工作是由compiler对象内部的compilation对象来完成的。

apply方法会在compiler对象创建完成之后调用，并将compiler对象作为参数传入。
apply方法在整个打包过程中只会执行一次 -- 可以理解为dom事件只需要注册一次，但是每次事件触发都会重新执行。
apply方法不会直接注册事件，所有的事件都是通过compiler和compilation对象注册的。比如在全部编译完成之后输出一句话：
```js
class MyPlugin {
  apply(compiler) {
    // 在内部注册事件
    // compiler.hooks.事件名称.事件类型('')
    compiler.hooks.done.tap('MyPlugin', (compilation) => {
      console.log('编译完成了')
    })
  }
}
```

- 事件名称： 要监听的webpack支持的事件，即钩子 -- [https://webpack.js.org/api/compiler-hooks/](https://webpack.js.org/api/compiler-hooks/)
- 事件类型： 基于Tapable API，这个小型库专门处理监听钩子函数监听，其中提供了三个事件类型
  1. tab： 同步监听
  2. tabAsync: 异步监听，通过回调函数处理，会传入第二个参数，是一个回调函数，调用该函数可以继续往下执行
  3. tabPromise: 异步监听，通过Promise处理，回调函数本身就可以定义为一个async函数

compilation对象：被compiler对象创建出来，进行编译和输出阶段的工作，compilation对象可以访问到要打包的模块和其依赖。
如果要为compilation模块注册事件，可以在compiler注册的事件中通过事件参数获取到compilation对象。从而注册事件：  
```js
class MyPlugin {
  apply(compiler) {
    compiler.hooks.beforeRun.tap('MyPlugin', (compilation) => {
      // 注册事件和compiler一样
      compilation.hooks.事件名称.事件类型('MyPlugin', (module) => {

      })
    })
  }
}

```
> 编译阶段工作：模块被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)

### 在最后生成文件前，多生成一个文件列表的txt文件
```js
class FileListPlugin {
  apply(compiler) {
    // 在emit阶段，生成文件列表
    compiler.hooks.emit.tap('FileListPlugin', (compilation) => {
      // 获取打包后的资源列表
      const assets = compilation.assets;
      const fileList = [];
      // 文件名 + 文件大小（kb为单位）
      for (const key in assets) {
        fileList.push(`${key} - ${assets[key].size() / 1024}kb`);
      }

      const fileContent = `打包后文件列表\n${fileList.join('\n')}`;
      compilation.assets['fileList.txt'] = {
        source: () => fileContent,
        size: () => fileContent.length
      }
    })
  }
}

module.exports = FileListPlugin;
```

## 区分打包环境
在`webpack.config.js`中可以导出一个函数，如果webpack识别为一个函数，则会调用这个函数，并将返回的对象融合到webpack的配置中。  
在函数中会获取到一个参数`env`，表示从命令行启动的时候的的`env`参数。
```json
"scripts": {
  "dev": "webpack --env.development",
  "build": "webpack --env.production"
}
```

```js
import webpackBaseConfig from './webpack.base.config';
import webpackDevConfig from './webpack.dev.config';
import webpackProdConfig from './webpack.prod.config';
// webpack.config.js
module.exports = (env) => {
  if (env.development) {
    return {
      ...webpackBaseConfig,
      ...webpackDevConfig
    }
  } else {
    return {
      ...webpackBaseConfig,
      ...webpackProdConfig
    }
  }
}
```

## 其他配置

### context

指定webpack的工作目录，默认为当前目录，context的值会影响到entry和loader的加载路径。  
比如设置到src目录下，所有相对路径都可以使用绝对路径 `context: path.resolve(__dirname, 'src')`

### output
output中其他配置：
- library: 
```js
module.exports = {
  output: {
    library: 'myLib',
  }
}
```
打包之后的自执行函数，在执行之后的执行结果，赋值给myLib变量。  
自执行函数的执行结果就是入口文件的模块导出对象。  
- libraryTarget:
指定暴露出来的变量要怎么处理
  - var: 暴露为一个变量，通过var 定义
  - window: 暴露为全局变量，直接挂载到window对象上
  - this: 暴露为全局变量，挂载到this对象上
  - commonjs: 暴露为commonjs模块，通过module.exports暴露

### target
表示打包后的运行环境，默认为web
- node: nodejs环境
- web: web浏览器环境

### module.noParse

用来忽略一些大型的单模块库，提高构建性能。

### resolve
- modules:
当导入模块的时候，如果没有指定`./`或者`../`，webpack会自动在`resolve.modules`中查找。

- extensions:
webpack导入模块的时候，允许缺失后缀名，webpack会根据extensions配置的顺序，补全文件的后缀名。补全后的文件名要存在于当前目录或者node_modules中。

- alias: 
创建模块的别名，当导入模块的时候，如果模块名与别名匹配，则直接使用别名。

### externals

告诉webpack，哪些模块不需要被打包，而是存在于其他环境，比如jquery，这些模块在打包的时候，不会被打包，而是直接使用。









